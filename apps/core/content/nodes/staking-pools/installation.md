---
head:
  - - meta
    - property: og:title
      content: Staking Pools Installation Guide
  - - meta
    - name: description
      content: How to install and deploy staking pools using the factory contract
  - - meta
    - property: og:description
      content: How to install and deploy staking pools using the factory contract
---

<script setup>
  import config from '@berachain/config/constants.json';
</script>

# Staking Pools Installation Guide

This guide provides step-by-step instructions for deploying staking pools using the `StakingPoolContractsFactory`. The factory contract handles the deployment of all necessary contracts and ensures they are properly configured for your validator.

## Prerequisites

Before proceeding with the installation, ensure you have:

- **Validator Setup**: A fully operational Berachain validator node
- **Validator Keys**: Your validator's public key and withdrawal credentials
- **Initial Stake**: At least {{ config.mainnet.minEffectiveBalance.toLocaleString() }} BERA for the initial deposit
- **Web3 Environment**: Access to a web3 provider (MetaMask, WalletConnect, or programmatic access)
- **Gas Fees**: Sufficient BERA for deployment and initialization transactions

:::warning
Staking pools are only available for new validators. Existing validators must perform a full withdrawal and recreate their validator to use staking pools.
:::

## System Architecture Overview

The staking pools system uses a factory pattern where the `StakingPoolContractsFactory` deploys and manages all related contracts:

- **StakingPoolContractsFactory**: Main factory contract that orchestrates deployment
- **StakingPool**: Core contract for user deposits and share management
- **SmartOperator**: Manages validator operations and PoL integration
- **StakingRewardsVault**: Manages rewards and auto-compounding
- **IncentiveCollector**: Handles incentive token collection and conversion

The system also includes shared infrastructure contracts:

- **WithdrawalVault**: Centralized contract that handles withdrawal requests and processing for all staking pools
- **AccountingOracle**: Permissionless oracle that provides consensus layer data validation and updates

## Step 1: Prepare Validator Data

### Generate Validator Keys

First, you need to generate your validator keys using the beacon client:

```bash
# Generate validator keys
beacond deposit validator-keys --home $BEACOND_HOME

# This will output your validator's public key in 48-byte hex format
# Example: 0x9308360bb1e8c237c2a4b6734782426e6e42bc7a43008ba5e3d9f3c70143227ea1fb2a08b21cbbedf87cebf27e81669d
```

### Prepare Withdrawal Credentials

Your withdrawal credentials must match what the smart contract expects based on its own withdrawal vault address. This is necessary because:

1. **Security**: The withdrawal vault address is deterministically calculated from your validator's public key
2. **Validation**: The smart contract validates that your withdrawal credentials match its expected withdrawal vault address
3. **Consensus Layer Integration**: The beacon deposit contract requires valid withdrawal credentials to register your validator

To generate the correct credentials:

1. **Calculate the predicted addresses** using the factory's `predictStakingPoolContractsAddresses` function
2. **Generate the withdrawal credentials** using the predicted withdrawal vault address (format: `0x01` + 11 \* `0x00` bytes + 20-byte withdrawal vault address)
3. **Create the deposit signature** with the correct withdrawal credentials using your beacon client

:::tip
The smart contract validates that your withdrawal credentials match what it expects based on its own withdrawal vault address. You need to calculate this in advance to generate the proper deposit signature.
:::

## Step 2: Deploy Staking Pool Contracts

### Using the Factory Contract

The `StakingPoolContractsFactory.deployStakingPoolContracts()` function handles the deployment of all necessary contracts in a single transaction:

```solidity
function deployStakingPoolContracts(
    bytes memory pubkey,           // Your 48-byte validator public key
    bytes memory withdrawalCredentials, // Withdrawal credentials (0x01 + 11 * 0x00 + withdrawal vault address)
    bytes memory signature,         // Deposit signature from beacon client
    address validatorAdmin,         // Address with admin privileges over your pool
    address defaultSharesRecipient  // Address to receive initial shares (usually your validator wallet)
)
    external
    payable
    returns (address, address, address, address);
```

### Deployment Parameters

- **`pubkey`**: Your validator's 48-byte public key in hex format
- **`withdrawalCredentials`**: Must be `0x01` + 11 \* `0x00` bytes + 20-byte withdrawal vault address (the smart contract validates this matches its expected value)
- **`signature`**: The deposit signature generated by your beacon client
- **`validatorAdmin`**: Address that will have administrative control over your pool (recommend using a multisig for security)
- **`defaultSharesRecipient`**: Address that receives the initial shares in the pool (typically your validator wallet)

### Required Value

The deployment transaction must include exactly 10,000 BERA as the initial deposit. This is necessary because:

1. **Consensus Layer Registration**: The factory automatically registers your validator with the consensus layer using this deposit
2. **Minimum Stake Requirement**: This meets the minimum stake required to register a validator on the consensus layer
3. **Automatic Processing**: The factory handles the deposit process automatically, eliminating the need for separate transactions

### Example Deployment Transaction

```javascript
// Using ethers.js
const factory = new ethers.Contract(factoryAddress, factoryABI, signer);

const tx = await factory.deployStakingPoolContracts(
  validatorPubkey, // 48-byte hex string
  withdrawalCredentials, // 0x01 + 11 * 0x00 + 20-byte address
  depositSignature, // From beacon client
  validatorAdminAddress, // Your admin address
  defaultSharesRecipient, // Your validator wallet
  { value: ethers.parseEther("10000") } // 10,000 BERA
);

const receipt = await tx.wait();
```

## Step 3: Verify Contract Deployment

### Check Deployed Addresses

After successful deployment, verify that the predicted addresses match the actual deployed addresses:

```solidity
function predictStakingPoolContractsAddresses(
    bytes memory pubkey
) external view returns (CoreContracts memory);
```

### Verify Contract State

Check that all contracts are properly initialized:

```solidity
// Get deployed contracts for your validator
function getCoreContracts(
    bytes memory pubkey
) external view returns (CoreContracts memory);
```

The returned `CoreContracts` struct contains:

- `smartOperator`: Address of your SmartOperator contract
- `stakingPool`: Address of your StakingPool contract
- `stakingRewardsVault`: Address of your StakingRewardsVault contract
- `incentiveCollector`: Address of your IncentiveCollector contract

Note that withdrawal processing and oracle services are handled by shared infrastructure contracts used by all staking pools, not deployed per validator.

## Step 4: Initialize the Pool

### Automatic Registration

The factory contract automatically registers your validator with the consensus layer during deployment. This is necessary because:

1. **Integrated Process**: The factory handles both contract deployment and validator registration in a single transaction
2. **Consensus Layer Integration**: Your validator must be registered with the consensus layer to begin earning rewards
3. **Operator Assignment**: The SmartOperator contract is automatically set as the validator's operator

**What Happens Automatically:**

- Validator registration with the consensus layer
- Operator address assignment to your SmartOperator contract
- Initial deposit processing (10,000 BERA)
- Withdrawal credentials validation

### Obtain Verification Proofs

After registration, you'll need to obtain proofs from the beacon API:

```bash
# Get validator index proof
curl "https://beacon-api.berachain.com/eth/v1/beacon/proof/validators/{validator_index}"

# Get withdrawal credentials proof
curl "https://beacon-api.berachain.com/eth/v1/beacon/proof/withdrawal_credentials/{validator_index}"

# Get initial balance proof
curl "https://beacon-api.berachain.com/eth/v1/beacon/proof/validators/{validator_index}/balance"
```

### Activate the Pool

Use the factory contract to activate your staking pool:

```solidity
function activateStakingPool(
    ValidatorData calldata validatorData,
    ProofData calldata proofData,
    uint64 timestamp
) external;
```

The `ValidatorData` struct includes:

- `pubkey`: Your validator's public key
- `withdrawalCredentials`: Your withdrawal credentials
- `operator`: Your SmartOperator contract address
- `initialBalance`: Your initial deposit amount

The `ProofData` struct includes:

- `indexProof`: Proof of your validator index
- `withdrawalCredentialsProof`: Proof of your withdrawal credentials
- `initialBalanceProof`: Proof of your initial balance
- `timestamp`: **Critical** - The timestamp of the beacon block used for verification

:::warning Timestamp Timing Requirement
**The timestamp must be from the next block after the one used to pull the proof.** This is because the verification process checks the proof against the beacon block root stored in EIP-4788.

**Example:**

- Proof pulled from block: 8796082 (timestamp 1756463197)
- Timestamp for verification: 1756463199 (block 8796083)
  :::

## Step 5: Configure Pool Operations

### Set Commission Rates

Configure your validator commission rate (maximum 100%):

```solidity
function setValidatorCommissionRate(uint256 commissionRate) external;
```

### Configure Reward Allocation

Set how Proof of Liquidity rewards are allocated:

```solidity
function setRewardAllocation(
    address[] memory rewardVaults,
    uint256[] memory weights
) external;
```

### Initialize BGT Operations

Set up BGT boost management for your validator:

```solidity
function queueBoost(uint256 amount) external;
function activateBoost() external;
```

## Deployment Verification Checklist

After completing the deployment, verify:

- [ ] All contracts deployed to predicted addresses
- [ ] Validator registered with correct withdrawal credentials
- [ ] Pool activated with valid proofs
- [ ] Commission rates configured
- [ ] Reward allocation set
- [ ] BGT operations initialized
- [ ] Pool accepting deposits (if desired)

## Troubleshooting Common Issues

### Deployment Failures

**Problem: Transaction fails with "Insufficient Value"**

**Debug Steps:**

1. **Check Transaction Value**: Ensure exactly 10,000 BERA is sent
2. **Verify Wallet Balance**: Confirm your wallet has sufficient BERA for deposit + gas
3. **Check Gas Estimation**: Ensure gas limit is sufficient for the complex deployment

**Debugging Commands:**

```solidity
// Check your wallet balance
uint256 balance = address(this).balance;

// Verify required amount
uint256 required = 10000 ether; // 10,000 BERA
```

**Problem: "Invalid Withdrawal Credentials" error**

**Debug Steps:**

1. **Verify Format**: Ensure credentials are `0x01` + 11 \* `0x00` bytes + 20-byte withdrawal vault address
2. **Check Predicted Address**: Use `predictStakingPoolContractsAddresses()` to get correct address
3. **Validate Signature**: Ensure deposit signature uses correct withdrawal credentials

**Debugging Commands:**

```solidity
// Get predicted withdrawal vault address
CoreContracts memory contracts = factory.predictStakingPoolContractsAddresses(pubkey);
address withdrawalVault = contracts.withdrawalVault;

// Generate correct withdrawal credentials
bytes memory credentials = abi.encodePacked(bytes1(0x01), new bytes(11), withdrawalVault);
```

:::danger BLS Signature Verification Not Supported
**Currently, smart contracts do not support BLS signature verification.** This limitation can lead to loss of funds if not properly understood. BLS signature support is planned for a future upgrade.
:::

**Problem: "Signature Verification Failed"**

**Debug Steps:**

1. **Verify Validator Keys**: Ensure signature is from correct validator keypair
2. **Check Withdrawal Credentials**: Confirm credentials in signature match deployment parameters
3. **Validate Signature Format**: Ensure signature is properly formatted from beacon client

### Activation Issues

**Problem: "Proof Verification Failed"**

**Debug Steps:**

1. **Check Proof Freshness**: Ensure proofs are recent (within 10 minutes)
2. **Verify Validator Index**: Confirm proofs are from correct validator index
3. **Validate Proof Data**: Ensure withdrawal credentials proofs match deployed contracts
4. **Check Beacon API**: Verify beacon API is responding and data is current

**Debugging Commands:**

```solidity
// Check if pool is active
bool active = stakingPool.isActive();

// Get validator pubkey
bytes memory pubkey = stakingPool.getValidatorPubkey();

// Check minimum effective balance
uint256 minBalance = stakingPool.minEffectiveBalance();
```

**Problem: Pool won't activate after successful deployment**

**Debug Steps:**

1. **Verify All Proofs**: Ensure index, withdrawal credentials, and balance proofs are provided
2. **Check Validator Data**: Confirm pubkey, withdrawal credentials, and operator match deployed contracts
3. **Validate Timestamp**: Ensure timestamp is within acceptable range (recent)
4. **Monitor Events**: Watch for `StakingPoolActivated` event

**Debugging Commands:**

```solidity
// Check deployed contracts
CoreContracts memory contracts = factory.getCoreContracts(pubkey);

// Verify contract addresses match predictions
CoreContracts memory predicted = factory.predictStakingPoolContractsAddresses(pubkey);
require(contracts.stakingPool == predicted.stakingPool, "Address mismatch");
```

### Common Error Messages

**"StakingPoolAlreadyActivated"**

- Pool has already been activated
- Check `isActive()` status before attempting activation

**"InvalidSender"**

- Function called by unauthorized address
- Verify caller has correct role permissions

**"InvalidAmount"**

- Amount parameter is zero or invalid
- Check all amount parameters are non-zero

**"TransferFailed"**

- BERA transfer failed
- Check contract has sufficient balance and gas

## Security Considerations

### Access Control

- **Admin Role**: Use a multisig wallet for admin privileges
- **Validator Operations**: Keep validator keys secure and separate from admin keys
- **Emergency Controls**: Understand pause and emergency exit mechanisms

### Contract Verification

- **Address Verification**: Always verify contract addresses before interactions
- **Proof Validation**: Ensure all proofs are recent and valid
- **Oracle Dependencies**: Monitor oracle updates for accuracy

## Next Steps

After successful deployment and activation:

1. **Test Operations**: Verify deposits, withdrawals, and reward distribution
2. **Monitor Performance**: Track pool performance and user activity
3. **Optimize Settings**: Fine-tune commission rates and reward allocation
4. **Community Building**: Attract users to your staking pool

## Support and Resources

- **Technical Documentation**: [Smart Contract Reference](/nodes/staking-pools/contracts)
- **Validator Community**: Join Berachain validator channels
- **Technical Support**: Contact Berachain technical support for deployment issues
